Ejercicio 4:

-------------------------------------------------------------------------------------------------

I) reverse . reverse = id

Por extensionalidad funcional quiero ver que:
∀ xs :: [a] --> reverse . reverse xs = id xs

Por induccion estructural en xs tengo que probar:

A) P([])

B) ∀ x :: a 
   P(xs) => P(x:xs)

Caso base:

reverse . reverse [] = id []
= {DEF (.)}
reverse (reverse []) = id []
= {DEF reverse}
reverse [] = id []
= {DEF reverse}
[] = id []
= {DEF id}
[] = []   --> Queda demostrado P([])

Caso inductivo:

{HI} : reverse . reverse xs = id xs

{Laux} : reverse (ys ++ [y]) = y : reverse ys

Qvq:
reverse . reverse (x:xs) = id (x:xs)

Lado izq:
reverse . reverse (x:xs)
= {DEF (.)}
reverse (reverse (x:xs))
= {DEF reverse}
reverse (reverse xs ++ [x])
= {Laux}
x : reverse (reverse xs)
= {HI}
x : id xs 
= {ID}
(x:xs) 

Lado der:
id (x:xs)
= {ID}
(x:xs) --> Como lado izq = lado der , queda demostrado.

Pruebo {Laux}:
por induccion estructural en ys :

Caso base P([])
reverse ([] ++ [y]) = y : reverse []
= {++0}
reverse (y:[]) = y : reverse []
= {DEF reverse}
reverse [] ++ [y] = y : reverse []
= {DEF reverse}
[] ++ [y] = y : reverse []
= {++0}
[y] = y : reverse []
= {DEF reverse}
[y] = [y]   --> Queda demostrado P([])

Caso inductivo P(ys) => P(y:ys)

{HI} : reverse (ys ++ [y]) = y : reverse ys

Qvq:
reverse ((y:ys) ++ [y]) = y : reverse (y:ys)

Lado izq:
reverse ((y:ys) ++ [y])
= {++1}
reverse (y : ys ++ [y])
= {DEF reverse}
reverse (ys ++ [y]) ++ [y]
= {HI}
y : reverse ys ++ [y]

Lado der:
y : reverse (y:ys)
= {DEF reverse}
y : reverse ys ++ [y]

como lado izq = lado der --> Queda demostrado.

-------------------------------------------------------------------------------------------------
QUIERO PROBAR reverse (x:xs) = reverse xs ++ [x]
sabiendo que :
{R0} reverse = foldl (flip (:)) []

induccion en xs

caos base
reverse (x : []) = reverse [] ++ [x]
reverse [x] = [x]

caso inductivo
reverse (x : (y:ys)) = reverse (y:ys) ++ [x]

foldl (flip (:)) [] (x: (y:ys))
foldl (flip (:)) (flip (:) [] x ) (y:ys)
foldl (flip (:)) [x] (y:ys)
foldl (flip (:)) (flip (:) [x] y) ys
foldl (flip (:)) ([x,y]) ys
