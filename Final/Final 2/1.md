```haskell
data AB a = Nil | Bin (AB a) a (AB a)

{P0} post nil = []
{P1} post (Bin i x d) = post d ++ post i ++ [x]

{M0} map f [] = []
{M1} map f (x:xs) = f x : (map f xs)

{A0} mapA f nil = []
{A1} mapA f (Bin i x d) = [f x]  ++ mapA f i ++ mapA f d

{R0} rev ac [] = ac
{R1} rev ac (x:xs) = rev (x : ac) xs

{++0} [] ++ ys = ys
{++1} (x:xs) ++ ys = x : (xs ++ ys)

{.} (f. g) x = f (g x) 

{lema-1} ≡ ∀xs, ys :: [a]. map f (xs ++ ys) = map f xs ++ map f ys
{lema-2} ≡ ∀xs, ys :: [a]. rev [] (xs ++ ys) = rev [] ys ++ rev [] xs
{lema-3} ≡ ∀xs :: [a]. xs ++ [] = xs
{lema-4} ≡ ∀xs, ac :: [a]. rev ac xs = rev [] xs ++ ac


∀f. a -> b. map f . post = rev [] . mapA f

-- Usando extensionalidad funcional tenemos que probar que:
∀f. a -> b, ∀t. AB a. (map f . post) t = (rev [] . mapA f) t

-- Usando induccion estructural sobre t, basta ver que:
1). Caso Base. P(Nil)
2). Caso Inductivo. ∀x :: a. (P(i) && P(d)) -> P(Bin i x d)
con P(t): ∀f. a -> b. map f . post t = (rev [] . mapA f) t

-- Caso Base:
(map f . post) Nil = (rev [] . mapA f) Nil
map f (post Nil) = rev [] (mapA f Nil) ≡ por {.}
map f [] = rev [] [] ≡ por {P0} y {A0}
[] = [] ≡ por {M0} y {R0}
-- Queda demostrado caso Base.

-- Caso inductivo:
-- Sea:
P(i) && P(d)  --> HI
-- Qvq:
∀x :: a. P(Bin i x d)

(map f . post) (Bin i x d) = (rev [] . mapA f) (Bin i x d)

-- Lado izq:
(map f . post) (Bin i x d)
map f (post (Bin i x d)) ≡ por {.}
map f (post d ++ post i ++ [x]) ≡ por {P1}
map f (post d) ++ map f (post i) ++ map f [x] ≡ por {lema-1} 2 veces
(map f . post) d ++ (map f . post) i ++ map f (x:[]) ≡ por {.}
(rev [] . mapA f) d ++ (rev [] . mapA f) i ++ map f (x:[]) ≡ por {HI}
(rev [] . mapA f) d ++ (rev [] . mapA f) i ++ f x : map f [] ≡ por {M1}
(rev [] . mapA f) d ++ (rev [] . mapA f) i ++ [f x] ≡ por {M0}

-- Lado der:
(rev [] . mapA f) (Bin i x d)
rev [] (mapA f (Bin i x d)) ≡ por {.}
rev [] ([f x]  ++ mapA f i ++ mapA f d) ≡ por {A1}
rev [] (mapA f d) ++ rev [] (mapA f i) ++ rev [] (f x : []) ≡ por {lema-2} 2 veces
(rev [] . mapA f) d ++ (rev [] . mapA f) i ++ rev [] (f x : []) ≡ por {.}
(rev [] . mapA f) d ++ (rev [] . mapA f) i ++ rev (f x : []) [] ≡ por {R1}
(rev [] . mapA f) d ++ (rev [] . mapA f) i ++ [f x] ≡ por {R0}
-- Queda demostrado caso inductivo, luego queda demostrado P(t).

-- Pruebo lema-1
∀xs, ys :: [a]. map f (xs ++ ys) = map f xs ++ map f ys

-- Uso induccion estructural sobre xs, basta ver que valen:
Caso Base. P([]).
Caso Inductivo. ∀x :: a, ∀xs' :: [a]. P(xs) => P(x:xs')
con P(xs) ≡ ∀ys :: [a]. map f (xs ++ ys) = map f xs ++ map f ys

-- Caso Base
map f ([] ++ ys) = map f [] ++ map f ys
map f ys = map f ys ≡ por {M0} 2 veces.
-- Queda demostrado caso Base.

-- Caso Inductivo:
-- Sea:
P(xs) ≡ ∀ys :: [a]. map f (xs ++ ys) = map f xs ++ map f ys

-- Qvq
∀x. [a], ∀xs' :: [a]. P(x:xs')

map f ((x:xs') ++ ys) = map f (x:xs') ++ map f ys

-- Lado izq:
map f ((x:xs') ++ ys)
map f (x : (xs' ++ ys)) ≡ por {++1}
f x : (map f (xs' ++ ys)) ≡ por {M1}
f x : (map f xs' ++ map f ys) ≡ por {HI}
(f x : (map f xs')) ++ map f ys ≡ por {:}

-- Lado der:
map f (x:xs') ++ map f ys
(f x : (map f xs')) ++ map f ys ≡ por {M1}

-- Queda demostrado caso inductivo.

-- Pruebo lema-2
∀xs, ys :: [a]. rev [] (xs ++ ys) = rev [] ys ++ rev [] xs

-- Por induccion estructural sobre xs basta ver que:
Caso Base. P([])
Caso Inductivo. ∀x:: a. ∀xs' :: [a]. P(xs) => P(x:xs')
Con P(xs) ≡ ∀ys :: [a]. rev [] (xs ++ ys) = rev [] ys ++ rev [] xs

-- Caso Base:
rev [] ([] ++ ys) = rev [] ys ++ rev [] []
rev [] ys = rev [] ys ++ [] ≡ por {++0} y {R0}
rev [] ys = rev [] ys ≡ por {lema-3}
-- Queda demostrado caso Base.

-- Caso inductivo.
-- Sea:
P(xs) ≡ ∀ys :: [a]. rev [] (xs ++ ys) = rev [] ys ++ rev [] xs
-- Qvq:
∀x :: a. ∀ xs :: [a].  P(x:xs')
rev [] ((x:xs') ++ ys) = rev [] ys ++ rev [] (x:xs')

-- lado Izq:
rev [] ((x:xs') ++ ys)
rev [] (x : (xs' ++ ys)) ≡ por {++1}
rev (x:[]) (xs' ++ ys) ≡ por {R1} 
rev [] (xs' ++ ys) ++ (x:[]) ≡ por {lema-4}
rev [] ys ++ rev [] xs' ++ (x:[]) ≡ por {HI}
rev [] ys ++ rev (x:[]) xs' ≡ por {lema-4}

-- lado der:
rev [] ys ++ rev [] (x:xs')
rev [] ys ++ rev (x:[]) xs'
-- Queda demostrado caso inductivo.

--pruebo lema-4
∀xs, ac :: [a]. rev ac xs = rev [] xs ++ ac

-- Uso induccion estructural.
-- Caso Base
rev ac [] = rev [] [] ++ ac
ac = [] ++ ac ≡ por {R0} 2 veces
ac = ac ≡ por {++0}

-- Caso inductivo
-- Sea
P(xs) ≡ ∀ac :: [a]. rev ac xs = rev [] xs ++ ac
-- Qvq:
P(x:xs')
rev ac (x:xs') = rev [] (x:xs') ++ ac

-- Lado izq:
rev ac (x:xs')
rev (x:ac) xs' ≡ por {R1}
rev [] xs' ++ (x:ac) ≡ por {HI}

-- Lado der:
rev [] (x:xs') ++ ac
rev (x:[]) xs' ++ ac ≡ por {R1}
rev [] xs' ++ (x:[]) ++ ac ≡ por {HI}
rev [] xs' ++ (x : ([] ++ ac)) ≡ por {++1}
rev [] xs' ++ (x:ac) ≡ por {++0}
-- Queda demostrado caso inductivo.
```