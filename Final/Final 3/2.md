```haskell
{A0} alt f g [] = [] 
{A1} alt f g (x:xs) = f x : alt g f xs

∀f :: a -> b, ∀g :: b -> c. alt g1 g2 . alt f1 f2 = alt (g1 . f1) (g2 . f2)

-- Uso extensionalidad funcional:
-- Quiero probar que:
∀xs :: [a], ∀f :: a -> b, ∀g :: b -> c. (alt g1 g2 . alt f1 f2) xs = alt (g1 . f1) (g2 . f2) xs

-- Caso Base:
(alt g1 g2 . alt f1 f2) [] = alt (g1 . f1) (g2 . f2) []

-- lado izq:
(alt g1 g2 . alt f1 f2) []
(alt g1 g2) (alt f1 f2 []) ≡ por {.}
alt g1 g2 [] ≡ por {A0}
[] ≡ por {A0}

-- lado der:
alt (g1 . f1) (g2 . f2) []
[] ≡ por {A0}
-- Queda demostrado el caso base.

-- Caso inductivo:
-- Sea HI:
(alt g1 g2 . alt f1 f2) xs = alt (g1 . f1) (g2 . f2) xs

-- Qvq:
(alt g1 g2 . alt f1 f2) (x:xs) = alt (g1 . f1) (g2 . f2) (x:xs)

-- Lado izq:
(alt g1 g2 . alt f1 f2) (x:xs)
(alt g1 g2) (alt f1 f2 (x:xs)) ≡ por {.}
(alt g1 g2) (f1 x : alt f2 f1 xs) ≡ por {A1}
g1 (f1 x) : alt g2 g1 (alt f2 f1 xs) ≡ por {A1}
g1 (f1 x) : (alt g2 g1 . alt f2 f1) xs ≡ por {.}
g1 (f1 x) : alt (g2 . f2) (g1 . f1) xs ≡ por {HI}

-- lado der:
alt (g1 . f1) (g2 . f2) (x:xs)
(g1 . f1) x : alt (g2 . f2) (g1 . f1) xs ≡ por {A1}
g1 (f1 x) : alt (g2 . f2) (g1 . f1) xs ≡ por {.}

-- Queda demostrado paso inductivo.

```